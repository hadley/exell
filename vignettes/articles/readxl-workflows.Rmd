---
title: "readxl Workflows"
date: "`r Sys.Date()`"
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(tibble.print_min = 3, tibble.print_max = 3)
delete_on_exit <- character()
```

*under development*

Ideas for using readxl to increase reproducibiliy and reduce tedium.

Reproducibility is much easier in theory than in reality. Here are some special dilemmas we face with spreadsheets:

  * We say: Keep raw data raw! But we also say: Store data in a tool-agnostic, future-proof format! If data comes in the form of an `.xls[x]` file, we're in a pickle. The `.xls[x]` file should obviously be preserved, and probably write-protected. But a faithful copy as CSV is a wonderful complement, as long as you can ensure the two are the same.
  * We say: Don't do analysis "by hand" or "by mouse"! But then we break this rule by manually exporting spreadsheets to file with *File > Save As ... > (save to `.csv`)*. readxl helps you get data directly out of a spreadsheet and into R, where you can record every step of your analysis as code. Below we show how to cache a CSV snapshot as part of this process.
  
The examples below also demonstrate the use of functional programming or "apply" techniques to iterate over the worksheets in a workbook.

## Load packages

We load the tidyverse metapackage here because the workflows below show readxl working with dplyr, purrr, etc.

We load readxl explicitly because it is not part of the core tidyverse.

```{r}
library(tidyverse)
library(readxl)
```


## Cache a CSV snapshot

Break analyses into logical steps, via a series of scripts that relate to one theme, such as "clean the data" or "make exploratory and diagnostic plots".

This forces you to transmit info from step i to step i + 1 via a set of output files. The cumulative outputs of steps 1, 2, ..., i are available as inputs for steps i + 1.

These outputs constitute an API for your analysis, i.e. they provide clean entry points that can be used (and understood) in isolation, possibly using an entirely different toolkit. Contrast this with the alternative of writing one monolithic script or transmitting entire workspaces via `save()`, `load()`, and R-specific `.rds` files.

If raw data is stored *only* as an Excel spreadsheet, this limits your ability to inspect it when solving the little puzzles that crop up in dowstream work. You'll need to fire up Excel (or similar) and get busy with your mouse. You certainly can't poke around it or view diffs on GitHub.

Solution: cache a CSV snapshot of your raw data tables at the time of export. Even if you use `read_excel()` for end-to-end reproducibility, this complementary CSV leaves your analysis in a more accessible state.

Pipe the output of `read_excel()` directly into `readr::write_csv()` like so:

```{r}
library(readr)

iris_xl <- read_excel(readxl_example("datasets.xlsx"), sheet = "iris") %>% 
  write_csv("iris-raw.csv")
```

```{r include = FALSE}
delete_on_exit <- c(delete_on_exit, "iris-raw.csv")
```

Why does this work? `readr::write_csv()` is a well-mannered "write" function: it does its main job *and returns its input invisibly*. The above command reads the iris sheet from readxl's `datasets.xlsx` example workbook and caches a csv version of the resulting data frame to file.

Let's check. Did we still import the data? Did we write the file?

```{r}
iris_xl
list.files(pattern = "iris")
```

Yes! Is the data written to CSV an exact copy of what we imported from Excel?

```{r}
iris_alt <- read_csv("iris-raw.csv")
## readr leaves a note-to-self in `spec` that records its column guessing,
## so we remove that attribute before the check
attr(iris_alt, "spec") <- NULL
identical(iris_xl, iris_alt)
```

Yes! If we needed to restart or troubleshoot this fictional analysis, `iris-raw.csv` is available as a second, highly accessible alternative to `datasets.xlsx`.

## Iterate over multiple worksheets in a workbook

Some Excel workbooks contain only data and you are tempted to ask "Why, God, why is this data stored in Excel? Why not store this as a series of CSV files?" One possible answer is this: because the workbook structure keeps them all together.

Let's accept that this happens and that it is not entirely crazy. How can you efficiently load all of that into R?

Here's how to load all the sheets in a workbook into a list of data frames:

  * Get a vector of worksheet names.
  * Use `lapply()` to iterate sheet reading.

```{r}
path <- readxl_example("datasets.xls")
xl_list <- lapply(excel_sheets(path), read_excel, path = path)
xl_list
```

## CSV caching and iterating over sheets

What if we want to read all the sheets in at once and simultaneously cache to CSV? We define `my_fun()` as `write_csv(read_excel(...))` and use `lapply()` again. We could even define this on-the-fly as an anonymous function inside `lapply()`, but I think this is more readable.

```{r}
my_fun <- function(x, path) {
  write_csv(read_excel(path = path, sheet = x), paste0("datasets-", x, ".csv"))
}
xl_list <- lapply(excel_sheets(path), my_fun, path = path)
xl_list
list.files(pattern = "\\.csv$")
```

```{r include = FALSE}
delete_on_exit <- c(delete_on_exit, list.files(pattern = "\\.csv$"))
```

In a real analysis, starting with workbook `"foo.xlsx"`, you might want to create the directory `foo` and place the CSVs inside that.

## Concatenate worksheets into one data frame

What if the datasets found on different sheets have the same variables? Then you'll want to row-bind them, after import, to form one big, beautiful data frame.

readxl ships with an example sheet `deaths.xlsx`, consisting of two worksheets named "arts" and "other". Each contains a data table of famous people who died in 2016 or 2017, but these tables have the same variables, e.g. name and date of death.

The `map_df()` function from purrr makes it easy to iterate over worksheets and glue together the resulting data frames, all at once.

  * Store a self-named vector of worksheet names (critical for the ID variable below).
  * Use `purrr::map_df()` to import the data, create an ID variable for the source worksheet, and row bind.

```{r}
library(purrr)
path <- readxl_example("deaths.xlsx")
(sheets <- path %>%
    excel_sheets() %>% 
    set_names())
deaths <- map_df(
  sheets,
  ~ read_excel(path, sheet = .x, range = "A5:E15"),
  .id = "sheet")
print(deaths, n = Inf)
```

Note the use of `range = "A5:E15"` here. `deaths.xlsx` is a typical spreadsheet and includes a few non-data lines at the top and bottom and this argument specifies where the data rectangle lives.

## Putting it all together

All at once now:

  * Multiple worksheets feeding into one data frame
  * Cache each worksheet to CSV upon import
  * Sheet-specific target rectangles

Even though the worksheets in `deaths.xlsx` have the same layout, we'll specify the target rectangle in two different ways here, to demonstrate how this works if each worksheet has it's own peculiar geometry.

```{r}
path <- readxl_example("deaths.xlsx")
(sheets <- path %>%
    excel_sheets() %>% 
    set_names())
ranges <- list("A5:E15", cell_rows(5:15))
my_fun <- function(x, path, range) {
  write_csv(read_excel(path = path, sheet = x, range = range),
            paste0("datasets-", x, ".csv"))
}
deaths <- map2_df(
  sheets,
  ranges,
  ~ read_excel(path, sheet = .x, range = .y),
  .id = "sheet")
print(deaths, n = Inf)
```

```{r include = FALSE}
delete_on_exit <- c(delete_on_exit, list.files(pattern = "\\.csv$"))
```

```{r include = FALSE}
delete_on_exit <- unique(delete_on_exit)
file.remove(delete_on_exit)
```

## Session info

```{r}
devtools::session_info()
```

